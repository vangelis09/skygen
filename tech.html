<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="bootstrap.min.css">
    <title>SkyGen</title>
  </head>
  <body>
      <header>
          <div class="header-area " >
              <div id="sticky-header" class="main-header-area">
                  <div class="container-fluid p-0">
                      <div class="header_bottom_border">
                          <div class="row align-items-center no-gutters">
                              <div class="col-xl-3 col-lg-2">
                                  <div class="logo">
                                      <a href="index.html">
                                          <img src="img/footer_logo.png" width="170px" alt="">
                                      </a>
                                  </div>
                              </div>
                              <div class="col-xl-6 col-lg-7">
                                  <div class="main-menu  d-none d-lg-block">
                                      <nav>
                                          <ul id="navigation">
                                              <li><a class="active" href="index.html">Главная</a></li>
                                              <li><a class="active" href="about.html">О нас</a></li>
                                              <li><a class="active" href="tech.html">Технологии</a></li>
                                              <li><a class="active" href="#">Услуги</a></li>
                                              <li><a class="active" href="contacts.html">Контакты</a></li>
                                          </ul>
                                      </nav>
                                  </div>
                              </div>

                              <div class="col-12">
                                  <div class="mobile_menu d-block d-lg-none"></div>
                              </div>
                          </div>
                      </div>

                  </div>
              </div>
          </div>
      </header>



      <!-- slider_area_start -->

      <div class="slider_area">
          <div class="slider_active owl-carousel">
              <div class="single_slider  d-flex align-items-center slider_bg_1 overlay">
                  <div class="container">
                      <div class="row align-items-center justify-content-center">
                          <div class="col-xl-9 col-md-9 col-md-12">
                              <div class="slider_text text-center">
                                  <h3>Информационная подсистема прогнозирования неисправностей
                                    ветрогенераторных электростанций
                                  </h3>

                              </div>
                          </div>
                      </div>
                  </div>
              </div>

          </div>
      </div>
      <!-- slider_area_end -->
      
    
      <section class="sample-text-area">
		<div class="container box_1170">
			<p class = "sample-text-right">
                Мавроматидис В. Ю. <br>
                Научный руководитель: ассистент каф. САПР Данильченко Е. В.
                <br>Южный федеральный университет
                <br>ИКТИБ, Таганрог 
                <br>mavromatidis@sfedu.ru

            </p>
            
            <h2 class="text-heading">РАЗРАБОТКА ГЕНЕТИЧЕСКОГО АЛГОРИТМА ДЛЯ МОДУЛЯ 
                ПРОГОЗИРОВАНИЯ НЕИСПРАВНОСТЕЙ ВЕТРОГЕНЕРАТОРОВ</h2>
			<p class="sample-text" style="font-style: italic;">
				В статье рассматривается применение алгоритмов 
                на основе эволюционных методов в сфере прогнозирования 
                неисправностей на ветрогенераторных электростанциях. 
                Производится анализ эффективности генетического алгоритма 
                в прогнозировании по сравнению с известными методами.
			</p>
            <p class="sample-text" style="text-transform: capitalize;">
                ВЕТРОГЕНЕРАТОРЫ, БИОИНСПИРИРОВАННЫЕ АЛГОРИТМЫ, ПРОГНОЗИРОВАНИЕ, 
                ЭВОЛЮЦИОННЫЕ МЕТОДЫ, ГЕНЕТИЧЕСКИЙ АЛГОРИТМ.
            </p>
            <p class="sample-text">
                В настоящее время для обслуживания ветрогенераторов привлекаются альпинисты для визуальных осмотров и используются беспилотные летательные аппараты, управляемые с земли. Хотя эти методы выполняют свою функцию, они требуют значительных временных и финансовых затрат, а также не обеспечивают возможности 
                прогнозирования неисправностей и их своевременного устранения.
            </p>
            <p class="sample-text">В рамках проекта “Специализированные дроны для прогнозного обслуживания ветрогенераторов” для решения данной проблемы были проведены исследования возможностей применения биоинспирированных алгоритмов на основе эволюционных вычислений для прогнозирования возникновения эксплуатационный неисправностей на ветрогенераторных электростанциях. </p>
            <p class="sample-text"><b>Генетический алгоритм (ГА)</b>— это эвристический алгоритм поиска, основанный на применении методов естественного отбора и эволюции, и используемый для решения задач моделирования, оптимизации и прогнозирования.</p>
            <p class="sample-text">
                <b style="font-size: larger;">Ключевые функции генетического алгоритма:</b>
                <br>1)	Создание первоначальной популяции;
                <br>2)	Мутация;
                <br>3)	Кроссигновер;
                <br>4)	Вычисление приспособленности (fitness-функция);
                <br>5)	Турнирный отбор.

                
            </p>
            <p class="sample-text">Для более подробного описания способа реализации данных методов в разработанном алгоритме приведен псевдокод:</p>
            <p class="sample-text"><b>Псевдокод 1. Создание начальной популяции</b>

                <br>vector<vector<NodeState>> initialize_population(int size, int num_nodes) {
                    <br>vector<vector<NodeState>> population(size, vector<NodeState>(num_nodes)); //Создаем вектор для хранения популяции 
                        <br>for (int i = 0; i < size; ++i) { 
                            <br>for (int j = 1; j < num_nodes; ++j) {
                                <br>population[i][j] = {
                                    <br>rand() % 5,  // blades_mechanical_damage
                                    <br>rand() % 5,  // flaps_condition
                                    <br>rand() % 5,  // corrosion
                                    <br>rand() % 5,  // icing
                                    <br>rand() % 5,  // rotary_mechanism
                                    <br>rand() % 5,  // wind_sensor
                                    <br>}; 
                                    <br>}//Заполняем параметры случайными числами от 0 до 5
                                    <br>}
                                    <br>return population; 
                                    <br>}
                </p>
            <p class="sample-text">Первоначальная популяция формируется путем присвоения каждому показателю случайно выбранного целочисленного значения от 0 до 5.</p>
            <p class="sample-text">
                <b>Псевдокод 2. Мутация</b>
                <br>void mutate(std::vector<NodeState>& individual, double mutation_rate) {
                    <br>for (size_t i = 1; i < individual.size(); ++i) {
                        <br>if (static_cast<double>(rng()) / rng.max() < mutation_rate) {
                            <br>individual[i].flaps_condition = 5 - individual[i].flaps_condition;
                            <br>individual[i].blades_mechanical_damage = 5 - individual[i].blades_mechanical_damage;
                            <br>individual[i].corrosion = 5 - individual[i].corrosion;
                            <br>individual[i].icing = 5 - individual[i].icing;
                            <br>individual[i].rotary_mechanism = 5 - individual[i].rotary_mechanism;
                            <br>individual[i].wind_sensor = 5 - individual[i].wind_sensor;
                            <br>}
                            <br>}
                            <br>}
            </p>
            <p class="sample-text">Функция мутации принимает в качестве параметров одного из “индивидов”, и значение mutation_rate, от которого зависит количество мутирующих параметров данного индивида. Далее случайно выбранные показатели меняются.</p>
            <p class="sample-text">
                <b>Псевдокод 3. Кроссинговер</b>
                <br>std::vector<NodeState> crossover(const std::vector<NodeState>& parent1, const std::vector<NodeState>& parent2) {
                    <br>std::vector<NodeState> child(parent1.size());
                        <br>for (size_t i = 1; i < parent1.size(); ++i) {
                            <br>    child[i] = (rng() % 2) ? parent1[i] : parent2[i];
                            <br>}
                            <br> return child;
                            <br>}

            </p>
            <p class="sample-text">С помощью функции кроссинговера, представленной в псевдокоде 3, из двух родительских индивидов формируется индивид потомка. Случайно выбранные параметры в равном количестве наследуются от каждого из родителей.</p>
            <p class="sample-text">
                <b>Псевдокод 4. Fitness-функция</b>
                <br>double fitness(const std::vector<NodeState>& individual, const std::vector<std::vector<int>>& G) {
                    <br>double fitness_value = 0.0;
                    <br>for (int node = 1; node < G.size(); ++node) {
                        <br>const auto& state = individual[node];
                        <br>fitness_value += state.flaps_condition * 3;
                        <br>fitness_value += state.blades_mechanical_damage * 2;
                        <br>fitness_value += state.corrosion * 1;
                        <br>fitness_value += state.icing * 0.1;
                        <br>fitness_value += state.rotary_mechanism * 0.5;
                        <br>fitness_value += state.wind_sensor * 0.5;
                        <br>}
                        <br>return fitness_value;
                        <br>}
            </p>
            <p class="sample-text">В псевдокоде 4 показана целевая функция, которая определяет уровень “приспособленности индивида”. В данном случае функция fitness определяет, насколько оптимальным является каждое найденное решение. </p>
            <p class="sample-text">
                <b>Псевдокод 5. Турнирный отбор</b>
                <br>vector<NodeState> tournament_selection(const vector<vector<NodeState>>& population, const vector<double>& fitnesses, int k) {
                    <br>vector<int> selected;
                        <br>  for (int i = 0; i < k; ++i) {
                            <br> int ind = rng() % population.size();
                            <br>selected.push_back(ind);
                            <br>}
                            <br>int best = selected[0];
                            <br>for (int i = 1; i < k; ++i) {
                                <br>if (fitnesses[selected[i]] > fitnesses[best]) {
                                    <br>best = selected[i];
                                    <br>}
                                    <br>}
                                    <br>return population[best];
                                    <br>}
                                            
            </p>
            <p class="sample-text">После выполнения всех предыдущих операций и вычисления приспособленности для индивида последующая популяция формируется методом турнирного отбора наиболее приспособленных индивидов, т. е. решений, показавших наиболее высокие значения целевой функции. Остальные, менее приспособленные индивиды, отсеиваются таким образом, чтобы размер популяции всегда оставался постоянным.</p>
            <p class="sample-text">В ходе данного исследования был проведен эксперимент, в котором разработанный алгоритм сравнивался с известными методами решения подобных задач, такими как алгоритм полного перебора и алгоритм отжига.</p>
            <p class="sample-text">Для эксперимента данные алгоритмы были применены для решения задачи нахождения оптимального значения целевой функции. В таблице 1, представленной ниже, собраны результаты работы каждого алгоритма. </p>
            <h5 class="mb-30">Таблица 1 - Результаты исследования</h5>
				<div class="progress-table-wrap">
					<div class="progress-table">
						<div class="table-head">
                            <div class="serial">№ п/п</div>
							<div class="country">Название алгоритма</div>
							<div class="visit">Значение целевой функции</div>
							<div class="visit">% к полностью оптимальному решению</div>
                            <div class="visit">Время выполнения алгоритма</div>
						</div>
						<div class="table-row">
                            <div class="serial">1</div>
							<div class="country">Алгоритм полного перебора</div>
							<div class="visit">141</div>
							<div class="visit">100%</div>
                            <div class="visit">0.07889</div>
						</div>
                        <div class="table-row">
                            <div class="serial">21</div>
							<div class="country">Алгоритм отжига</div>
							<div class="visit">92.3</div>
							<div class="visit">65.5%</div>
                            <div class="visit">0.00131</div>
						</div>
                        <div class="table-row">
                            <div class="serial">3</div>
							<div class="country">Генетический алгоритм</div>
							<div class="visit">125.4</div>
							<div class="visit">88.9%</div>
                            <div class="visit">0.00964</div>
						</div>
						
					</div>
				</div>
            <br>
            <p class="sample-text-center">
                <br><img src="img/gr1.png" width="80%" alt="graph1" style="align-items: center;">
                <br><br>Рисунок 1 – Сравнение показателей целевой функции и процентое отношение к полностью оптимальному решению
                <br><br><img src="img/gr2.png" width="80%" alt="graph2">
                <br><br>Рисунок 2 – Сравнение времени выполнения алгоритмов
            </p>
            <p class="sample-text">
                <b>Заключение.</b> Результаты исследования показали, что разработанный генетический алгоритм способен находить значение, достаточно близкое к оптимальному, при затратах времени примерно в 8 раз меньших, чем потребовалось для поиска абсолютного оптимума методом полного перебора. Алгоритм отжига выполняется быстрее, чем алгоритм, основанный на эволюционных методах, но его точность гораздо ниже.
            </p>
            <p class="sample-text">Таким образом, разработанный алгоритм может успешно применяться для решения задач, связанных с прогнозированием неисправностей ветрогенераторов, выдавая результат, близкий к оптимальному, за приемлемое время.</p>
            <p class="sample-text"><b>Поддержка.</b> Исследование выполнено за счет гранта Российского научного фонда No 24-71-00035, https://rscf.ru/project/24-71-00035/ в Южном федеральном университете.</p>
            <br><br><h4>Библиографический список</h4>
            <p class="sample-text">    
            <BR></BR>1. А.С. Татевосян. Практикум по технологиям разработки алгоритмов интеллектуальных инфориационных систем: Методические указания для проведения лабораторных занятий по дисциплине «Интеллектуальные информационные системы»  Омск: Изд-во ОмГТУ , 2008. – 60 с.
            </p>
            
		</div>
	</section>
	<!-- End Sample Area -->

      <!-- Start Sample Area -->
	<section class="sample-text-area">
		<div class="container box_1170">
             
			<p class = "sample-text-right">
                Д.М. Хоменко <br>
                Научный руководитель: ассистент каф. САПР Данильченко Е. В.
                <br>Южный федеральный университет
                <br>ИКТИБ, Таганрог 

            </p>
            
            <h2 class="text-heading">ПРОГРАММНАЯ РЕАЛИЗАЦИЯ СИМУЛЯЦИИ МАРШРУТИЗАЦИИ И ПОЛЕТА БПЛА С ПРИМЕНЕНИЕМ АЛГОРИТМОВ НА ОСНОВЕ ПОВЕДЕНИЯ КОЛОНИИ МУРАВЬЕВ 
                ДЛЯ ЗАДАЧ АНАЛИЗА СОСТОЯНИЯ ВЕТРОГЕНЕРАТОРОВ</h2>
			<p class="sample-text" style="font-style: italic;">
				<b>Аннотация.</b> Статья посвящена разработке и программной реализации симуляции маршрутизации и полета БПЛА с применением биоинспирированных алгоритмов искусственного интеллекта. Целью работы является создание платформы для разработки и тестирования алгоритмов маршрутизации БПЛА и моделирования полетов в различных условиях и рабочих зонах. В работе рассматриваются реализация механизма преобразования трехмерного пространства рабочей зоны в двумерное пространство, пригодное для работы с алгоритмами маршрутизации на графах, разработка алгоритмов маршрутизации, основанных на поведении муравьиной колонии, симуляция полета БПЛА с определенными целями. Проводится сравнительный анализ и экспериментальные исследования полученных алгоритмов маршрутизации. В заключительной части статьи рассматривается возможность интеграции разработанной системы в промышленные процессы и ее потенциал для дальнейшего развития.
			</p>
            <p class="sample-text" style="text-transform:uppercase">
                адаптивный алгоритм, окто-деревья, моделирование, симулирование, маршрутизация, реальное время, БПЛА, модели искусственного интеллекта, роевые алгоритмы, 
                биоинспирированные подходы, муравьиные алгоритмы.
            </p>
            <p class="sample-text">
                <b>Введение.</b> Задача маршрутизации движения различных устройств, включая беспилотные летательные аппараты (БПЛА, дрон, англ. UAV), является одной из ключевых в современной робототехнике. Данная задача заключается в планировании безопасной траектории движения устройства в рабочей зоне из начального состояния в целевое конечное состояние.
            </p>
            <p class="sample-text">Для решения задач маршрутизации зачастую применяются классические методы на основе графов, дорожных карт,  клеточной декомпозиции, потенциальных полей и др. Однако в последнее время с ростом вычислительных мощностей аппаратного обеспечения все более часто успешно применяются эвристические и метаэвристические методы решения задач маршрутизации, вдохновленные природными явлениями и не имеющие строгого математического обоснования. Среди таких методов следует выделить, например, эволюционные методы, метод имитации отжига, роевые алгоритмы, реактивные методы, а также методы искусственного интеллекта:  нейросетевые методы, методы нечеткой логики и др. Вышеупомянутые методы лишены недостатков, присущих классическим методам и обладают несомненными преимуществами, гарантируя высокую надежность и скорость поиска решения.</p>
            <p class="sample-text">Данная статья описывает программную реализацию алгоритма маршрутизации БПЛА в симулируемой средствами компьютера среде. Применение симуляции при решении целевой задачи позволяет избежать высоких материальных затрат и ускорить создание и совершенствование используемых методов маршрутизации. При этом среда, в которой проводятся испытания, остается максимально приближенной к той, чьи свойства были взяты за основу, что позволяет без труда перенести разработанное ПО из симулируемой среды в реальную.</p>
            <p class="sample-text">
               <b>Снижение размерности пространства маршрутизации.</b> Маршрутизация в трехмерном пространстве – это сложная задача, требующая комплексного подхода, при этом декомпозирование позволяет сильно ее упростить. Один из вариантов декомпозиции задачи предполагает построение на основе исходного трехмерного пространства полного графа маршрутов. Данный переход позволяет снизить размерность пространства с трехмерного до двумерного, что открывает широкие возможности для применения алгоритмов маршрутизации на графе.
            </p>
            <p class="sample-text">Основная задача, решаемая при переходе от трехмерного пространства к двумерному, это нахождение пути между двумя точками исходного пространства и создание двумерной матрицы переходов. При этом прокладываемый путь не должен пересекаться ни с одним объектом выбранного пространства.</p>
             <p class="sample-text">Для снижения ресурсных затрат при выполнении маршрутизации перехода между точками призвано разбиение пространства на древовидную структуру, в которой у каждого внутреннего узла ровно восемь «потомков» (окто-дерево). Таким образом гораздо проще определять препятствия и искать обходные пути для маршрутизируемого объекта, так как нет необходимости выполнять поиск пересечения на полной геометрии объектов в симуляции, вместо этого пространство маршрутизации заменяется упрощенной моделью.</p>
            <p class="sample-text">Псевдокод 1 демонстрирует реализацию построения матрицы маршрутов на основе контрольных точек (КТ) участвующих в симуляции. <br>
            <br>// Определение структур
            <br>// Структура звена маршрута
            <br>struct CPathNode {
            <br>std::vector<float> worldLocation;
            <br>std::vector<float> normal;
            <br>};
            <br>// Структура данных маршрута
            <br>struct PathData {
            <br>std::vector<CPathNode> path;
            <br>float length;
            <br>};
            <br>// Строка матрицы
            <br>struct PathMatrixRow {
            <br>std::vector<PathData> row;
            <br>};
            <br>// Матрица маршрутов
            <br>struct PathMatrix {
            <br>std::vector< PathMatrixRow > matrix;
            <br>};
<br>
            <br>// Класс, реализующий построение полного графа маршрутов
            <br>class PathsBuilder {
            <br>private:
            <br>PathMatrix graph;
            <br>PathVolume NavVolume;
            <br>public:
            <br>// Метод для вызова построения матрицы
            <br>PathMatrix BuildPaths(PathVolume domain) {
<br>                // Установка домена
                <br>NavVolume = domain;
                <br>// Очистка матрицы
                <br>graph.clear;
                <br>// Запуск построения
                <br>if(!NavVolume.WaypointsHandler.Waypoints.isEmpty){
<br>                    InitPathMatrix(graph);
                    <br>FindPaths(NavVolume.WaypointsHandler.Waypoints);
                <br>}
                <br>return graph;
            <br>}
            <br>private:
            <br>// Циклическое формирование переходов
            <br>void FindPaths(Waypoint points) {
                <br>for(int i = 0; i<(points.last-1); i++)
                    <br>for(int j = i+1; j<points.last; j++){>
                        <br>PathData path = FindPathBetweenPoints(points[i],points[j],5,1);
                        <br>graph.SetElem(i, j, path);
                        <br>graph.SetElem(j, i, InvertPath(path));
                    <br>}
            <br>}
            <br>// Метод построения перехода межу контрольными точками
            <br>PathData FindPathBetweenPoints(Waypoint W1, Waypoint W2, int smoothing, float timeLimit) {
<br>                // Обращение к домену маршрутизации и нахождение маршрута в окто-дереве
    <br>            // возвращает маршрут
            <br>}
            <br>void InitPathMatrix(PathMatrix matrix) {
<br>                // Инициализация матрицы
    <br>            // заполняет матрицу нулевыми значениями до необходимого размера
        <br>    }
            <br>PathData InvertPath(PathData path) {
                <br>// Инвертирование маршрута
            <br>}
            <br>// Дополнительные методы
            <br>};//> </p>
            <p class="sample-text"><b>Алгоритмы маршрутизации на основе поведения колонии муравьев.</b> Как было упомянуто ранее существует множество методов решения исследуемой задачи, однако стоит выделить муравьиный алгоритм из группы роевых, который обладает высокой эффективностью и скоростью нахождения оптимального пути, а также возможностью непрерывного использования [1, 2]. Данный метод основывается на поведении колонии муравьев, которые находятся в поисках добычи. Муравьи, двигаясь испускают феромоны, тем самым формируя различные маршруты, однако феромон со временем испаряется, что приводит к тому, что наиболее длинные маршруты исчезают, уступая наиболее коротким [3, 4, 5].</p>
            <p class="sample-text">В данной статье будут затронуты классический и модифицированный варианты алгоритма. В математическую модель алгоритма была включена нормализация масштабов пространства и регулировка соотношения глобального объема феромонов к масштабу пространства. Данная модификация позволяет эффективно использовать алгоритм в пространствах разных размеров. Также алгоритм был модифицирован добавлением процедуры прохода элитных муравьев, которая увеличивает количество феромона на наилучшем маршруте.</p>
            <p class="sample-text">Нормализация пространства происходит путем введения делителя дистанции перехода. Таким образом делитель сокращает реальную дистанцию перехода при вычислениях, влияя тем самым на веса переходов, а также на распределение феромона по переходу. Делитель же в свою очередь зависит от конфигурации пространства, чем оно больше, тем больше делитель. Помимо этого, делитель влияет на базовый объем феромона, чем он выше, тем больше феромона будет распределено. При помощи соотношения баланса можно влиять на степень влияния делителя на расстояния переходов и базовый объем феромона, увеличивая один параметр и снижая при этом другой.</p>
            <p class="sample-text">Псевдокод 2 описывает программную реализацию модифицированного муравьиного алгоритма.
<br>                // Определение структур
<br>// Структура параметров алгоритма
<br>struct AntAlgoParams {
<br>	//Параметры алгоритма
<br>};
<br>// Структура строки матрицы булевых значений
<br>struct BoolMatrixRow {
<br>	std::vector<bool> row;
<br>};
<br>// Структура булевых значений
<br>struct BoolMatrix {
<br>	std::vector<BoolMatrixRow> rows;
<br>};
<br>// Структура строки матрицы float значений
<br>struct FloatMatrixRow {
<br>	std::vector<float> row;
<br>};
<br>// Структура булевых значений
<br>struct FloatMatrix {
<br>	std::vector<FloatMatrixRow> rows;
<br>};
<br>// Структура ряда весов
<br>struct FloatRoulette {
	<br>int pos;
	<br>float value;
<br>};
<br>// Структура весов переходов
<br>struct Weights {
<br>	std::vector<FloatRoulette> array;
<br>	float weightsSum;
<br>};
<br>
<br>// Класс, реализующий алгоритм маршрутизации
<br>class AntAlgorithm {
<br>private:
  <br>PathMatrix graph;
  <br>TimerHandler mainLoopTimer;
  <br>BoolMatrix passed;
  <br>FloatMatrix feromone;
  <br>int iteration = 0;
  <br>int maxIteration = 1;
  <br>bool newLoopFlag = true;
  <br>int currentPos;
<br>public:
  <br>//
  <br>// Параметры алгоритма
  <br>//
<br>  
<br>  // Метод для вызова выполнения алгоритма
  <br>void StartAntAlgo(PathMatrix matrix, AntAlgoParams AAParams) {
    <br>SetParams(AAParams);
	<br>graph = matrix;
	<br>StartMainLoop();
  <br>}
<br>private:
  <br>void SetParams(AntAlgoParams AAParams) {
    <br>// Установка параметров алгоритма
  <br>}
  <br>void InitData(PathMatrix matrix) {
    <br>// Инициализация всех необходимых переменных и массивов
  <br>}
  <br>void StartMainLoop() {
	<br>// Установка таймера итераций
	<br>// переданное в функцию событие будет выполняться постоянно 
	<br>// с указанным периодом, пока таймер не будет остановлен
	<br>mainLoopTimer = SetTimerByEvent(iterateLoop_event, updateTime, true);
  <br>}
  <br>void CheckLoopGates() {
	<br>// Проверка разрешений на запуск итерации, передачу маршрута
  <br>}
  <br>void AssemblePath() {
	<br>// Формирует путь и передает его внешним объектам
  <br>}
  <br>int InitStartPositionAndLoopCount() {
	<br>// Выдает алгоритму начальную позицию и количество циклов обработки
  <br>}
  <br>Weights CalcWeights(int pos, BoolMatrix passed, FloatMatrix feromone, 
  <br>PathMatrix graph, float feromoneInfl, float distanceInfl) {
<br>	// Вычисляет веса переходов
<br>	// Возвращает набор весов и индексов вершин ассоциированных с ними
  <br>}
  <br>Weights CalcProbabilities(Weights weights, BoolMatrix passed, int pos) {
	<br>// Вычисляет вероятности переходов
	<br>// Возвращает набор вероятностей и индексов вершин ассоциированных с ними
  <br>}
  <br>int MakeChoise(Weights probabilities) {
	<br>// Выбирает случайным образом переход в зависимости от вероятности
  <br>}
  <br>void MoveToNextPos(int newPos, int *pos, float antCapMul, float feromoneBase,
  <br>AntPath *path, BoolMatrix passed, FloatMatrix feromone, PathMatrix graph) {
	<br>// Выполняет переход муравья, распределяя феромон
  <br>}
  <br>void ResetData() {
	<br>// Подготовка алгоритма к новой итерации
  <br>}
  <br>void ValuePostUpdate() {
	<br>// Процедуры испарения феромона, 
	<br>// поиска лучшего маршрута в новом наборе, прохода элитных муравьев
  <br>}
  <br>void IterateLoop() {
	<br>if(CheckLoopGates())
<br>		AssemblePath();
<br>	if(iteration < maxIteration){
		<br>iteration++;
		<br>newLoopFlag = false;
		<br>int loopCount = InitStartPositionAndLoopCount();
		<br>for(int i = 0; i < loopCount; i++){
<br>			Weights weights = CalcWeights(currentPos, passed, feromone, graph, feromoneInfl, distanceInfl);
			<br>Weights probabilities = CalcProbabilities(weights, passed, currentPos);
			<br>int newPos = MakeChoise(probabilities);
			<br>MoveToNextPos(newPos, currentPos, UAntCapMul, feromoneBase, path, feromone, passed, graph);
		<br>}
		<br>MoveToNextPos(startPos, currentPos, UAntCapMul, feromoneBase, path, feromone, passed, graph);
		<br>ResetData();
		<br>if((iteration % antsValue) == 0){
		<br>	ValuePostUpdate();
		<br>}
		<br>newLoopFlag = true;
	<br>}
  <br>}
  <br>// Дополнительные методы
<br>};      </p>
            <p class="sample-text"><b>Симуляция процедуры анализа состояния ветрогенераторов при помощи БПЛА.</b> В процессе проведения исследований был разработан симулятор в инструментальном средстве Unreal Engine 5, благодаря которому возможна быстрая разработка и тестирование применяемых технологий маршрутизации. Разработанный симулятор предоставляет возможности конфигурирования симулируемой среды, создания упрощенной модели пространства, построения переходов между КТ, выполнения алгоритма маршрутизации, а также выполнения полета БПЛА.</p>
            <p class="sample-text">Ниже на рисунке 1 представлена упрощенная модель пространства в виде окто-дерева, которая отображена зелеными линиями, на рисунке 2 показан полный граф переходов между контрольными точками, которые в данном контексте являются ветрогенераторами, на рисунке 3 показан результат маршрутизации модифицированным муравьиным алгоритмом, на рисунке 4 показан полет БПЛА по заданному маршруту. </p>
            <p class="sample-text-center">
                <br><img src="img/mar1.png" width="80%" alt="graph1" style="align-items: center;">
                <br><br>Рисунок 1 – Окто-дерево пространства, представленное в виде подразделяющейся кубической структуры
                <br><br><img src="img/mar2.png" width="80%" alt="graph2">
                <br><br>Рисунок 2 – Полная сеть переходов между точками
                <br><br><img src="img/mar3.png" width="80%" alt="graph2">
                <br><br>Рисунок 3 – Наилучший маршрут, показанный голубой линией
                <br><br><img src="img/mar4.png" width="80%" alt="graph2">
                <br><br>Рисунок 4 – Дрон выполняет полет по заданному курсу
            </p>
            <p class="sample-text"><b>Эксперимент.</b> Для проведения тестирования эффективности алгоритмов были установлены следующие условия:
                <br> - количество вершин в графе должно быть равно 45, их положение не должно меняться от испытания к испытанию;
                <br> - период обновления алгоритма должен быть равен 0,04 секунды;
                <br> - количество итераций не ограничено;
                <br> - размер популяции должен быть ограничен 15 муравьями.
</p>
            <p class="sample-text">Было выявлено эталонное значение длины маршрута, для графа, состоящего из 45 вершин, это значение равняется 1,500,000 (UE units). На основе эталона было определено неоптимальное решение, которое равно 3,000,000, таким образом возможно построение опорных решений для определения временных затрат на повышение качества маршрута.</p>
            <p class="sample-text">Для выявления скоростных характеристик был создан набор опорных значений, включающий в себя:
                <br> - 25% качества решения – если длина маршрута меньше, чем 2,700,000;
                <br> - 50% качества решения – если длина маршрута меньше, чем 2,250,000;
                <br> - 75% качества решения – если длина маршрута меньше, чем 1,870,000;
                <br> - 90% качества решения – если длина маршрута меньше, чем 1,650,000;
</p>
            <p class="sample-text">Фиксация времени будет проводиться с помощью отдельного модуля контроля, который ведет подсчет времени во время процесса нахождения маршрута. Если алгоритм находит решение, которое лучше, чем опорное значение, модуль записывает время, за которое оно было найдено.</p>
            <p class="sample-text">В процессе эксперимента было проведено сравнение скорости классического и модифицированного муравьиных алгоритмов. После проведения ряда испытаний были получены результаты от обоих алгоритмов и отображены на графике зависимости качества решения от времени выполнения алгоритмов, который представлен ниже.</p>
            <p class="sample-text-center">
                <br><img src="img/mar5.png" width="80%" alt="graph1" style="align-items: center;">
                <br><br>Рисунок 5 – График времени затраченного на улучшение решения (чем ниже, тем лучше)
            </p>
            <p class="sample-text">Согласно приведенным результатам, модифицированный алгоритм превосходит классический в скорости нахождения оптимального решения, соответствующего уровням критерия. Для нахождения решения, соответствующего 90% качества модифицированному алгоритму нужно 30,9 секунд, что на 14,12 секунд меньше, чем классическому варианту, который находит такое же по качеству решение за 45,02 секунды.</p>
            <h4>Заключение</h4>
            <p class="sample-text">Исследование показало, что система маршрутизации БПЛА, с применением алгоритмов, основанных на поведении колонии муравьев, демонстрирует высокую точность, надежность и результативность при формировании маршрутов в различных условиях. Использование симуляции при проведении исследования позволило значительно увеличить скорость и простоту разработки, а также расширило возможности интеграции в разные сферы деятельности, таким образом возможно взаимодействие не только с ветрогенераторами, но и с другими объектами, например нефтегазовой промышленности. Таким образом разработанная система имеет потенциал для практического внедрения в процессы объектов промышленности, что может значительно снизить расходы и повысить безопасность.</p>
            <p class="sample-text">Перспективы дальнейших исследований включают расширение функциональности системы путем развития средств управления симулируемой средой, обеспечение возможности разработки и интеграции пользователем собственных алгоритмов маршрутизации, без необходимости полной перекомпиляции исходников, внедрение асинхронного выполнения алгоритмов маршрутизации на нескольких потоках в целях улучшения эффективности, производительности и отзывчивости симулятора.</p>
            <p class="sample-text">Работа по разработке симуляции маршрутизации БПЛА на основе поведения колонии муравьев для задач анализа состояния ветрогенераторов представляет собой важный шаг в направлении повышения эффективности и безопасности в задачах обслуживания объектов промышленности. Полученные результаты подтверждают потенциал предложенного подхода и готовность его к практическому применению. Дальнейшие исследования и разработки в этой области могут помочь спровоцировать рост различных отраслей промышленности.</p>
            <p class="sample-text"><b>Поддержка.</b> Исследование выполнено за счет гранта Российского научного фонда No 22-71-10121, https://rscf.ru/project/22-71-10121/ в Южном федеральном университете.</p>
            <h4>Библиографический список</h4>
            <p class="sample-text">
                
               <br> 1.	Нейдорф Р.Ф., Полях В.В., Черногоров И.В., Ярахмедов О.Т., "Исследование эвристических алгоритмов в задачах прокладки и оптимизация маршрутов в среде с препятствиями". Известия ЮФУ. Компьютерные и информационные науки, № 16, 2016. С. 2-17.
                <br>2.	Курейчик В.М., Кажаров A.A., "Использование роевого интеллекта в решении NP-трудных задач". Известия ЮФУ. Технические науки, Т. 120, № 7, Июль 2011. С. 30-36.
                <br>3.	Кажаров A.A., Курейчик В.М. Модификации муравьиного алгоритма для решения задачи коммивояжера // Труды международной научно-технической конференции "Интеллектуальные системы AIS'08". 2008.
                <br>4.	Курейчик В.М., Кажаров A.A., "О некоторых модификациях муравьиного алгоритма", Известия ЮФУ. Технические науки, № 4, Апрель 2008. С. 7-12. 
                <br>5.	Кажаров A.A. Модификации муравьиных алгоритмов и их применение к задаче коммивояжера // Сборник трудов 15-й Всероссийской межвузовской научно-технической конференции студентов и аспирантов «Микроэлектроника и информатика-2008». Зеленоград. 2008.

            </p>
            
           
		</div>
	</section>
	<!-- End Sample Area -->
       <!-- footer_start  -->
    <footer class="footer">
        <div class="footer_top">
            <div class="container">
                <div class="row">
                    <div class="col-xl-3 col-md-6 col-lg-3 ">
                        <div class="footer_widget">
                            <div class="footer_logo">
                                <a href="#">
                                    <img src="img/footer_logo.png" alt="" style="height: 150px;">
                                </a>
                            </div>
                            <br>
                            <p>Южный Федеральный университет;<br>
                                347928, г. Таганрог <br> пер. Некрасовский, 44; <br>
                                  <a href="#">+7(964)042-9292</a> <br>
                                  <a href="#">mavromatidis@sfedu.ru</a>
                              </p>
                            <p>



                            </p>

                        </div>
                    </div>
                    <div class="col-xl-4 col-md-6 col-lg-4 offset-xl-1">
                        <div class="footer_widget">
                            <h3 class="footer_title">
                                <br><br><br><br><br><br><br><br>    
                            </h3>
                            <ul>
                                <li><a href="#">Технологии</a></li>
                                <li><a href="#">О нас</a></li>
                                <li><a href="#"> Услуги</a></li>
                                <li><a href="#"> Контакты</a></li>
                            </ul>
                        </div>
                    </div>
                    <div class="col-xl-4 col-md-6 col-lg-4">
                        <div class="footer_widget">
                            <br><br><br>
                            <h3 class="footer_title" style="color: aqua;">
                                <br><br><br><br><br><br>Быстрая заявка
                            </h3>
                            <p class="newsletter_text">
                                Введите email для связи: 
                            </p>
                            <form action="#" class="newsletter_form">
                                <input type="text" placeholder="Enter your mail">
                                <button type="submit">Отправить</button>
                            </form>
                           
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="copy-right_text">
            <div class="container">
                <div class="footer_border"></div>
                <div class="row">
                    <div class="col-xl-12">
                        <p class="copy_right text-center">
                            г.Таганрог 2025 г.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </footer>
    <!-- footer_end  -->
  </body>
</html>
